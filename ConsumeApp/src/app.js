#!/usr/bin/env node

/**
 * Secret Consumer iApp for iExec
 * 
 * This iApp consumes secrets that were generated by the TargetApp (Secret Generator)
 * and pushed to the SMS (Secret Management Service).
 * 
 * The secret is accessed via IEXEC_REQUESTER_SECRET_1 environment variable.
 * 
 * Usage:
 *   args: "action" (validate, use-api, encrypt, hash, info)
 *   requesterSecrets: { 1: "my-secret" }  // The secret name pushed to SMS
 */

import { createHash, createCipheriv, randomBytes } from 'crypto';
import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';

// Environment variables provided by iExec TEE
const IEXEC_OUT = process.env.IEXEC_OUT || './output';
// Update to check for App Secret first, then fallback to Requester Secret
const APP_DEVELOPER_SECRET = process.env.IEXEC_APP_DEVELOPER_SECRET;
const REQUESTER_SECRET_1 = process.env.IEXEC_REQUESTER_SECRET_1;
const SECRET_TO_USE = APP_DEVELOPER_SECRET || REQUESTER_SECRET_1;

/**
 * Validate that a secret exists and has the expected format
 * @param {string} secret - The secret to validate
 * @returns {object} Validation result
 */
function validateSecret(secret) {
    if (!secret) {
        return {
            valid: false,
            error: 'No secret provided',
            details: null
        };
    }

    // Detect secret type based on format
    let detectedType = 'unknown';
    let details = {};

    if (secret.match(/^[a-z]{4}_[A-Za-z0-9]{32}$/)) {
        detectedType = 'api-key';
        details = {
            prefix: secret.split('_')[0],
            keyLength: 32
        };
    } else if (secret.match(/^0x[a-fA-F0-9]{64}$/)) {
        detectedType = 'private-key';
        details = {
            format: 'ethereum-compatible',
            bits: 256
        };
    } else if (secret.match(/^[a-fA-F0-9]{64}$/)) {
        detectedType = 'hex';
        details = {
            bits: 256
        };
    } else if (secret.match(/^[A-Za-z0-9+/]+=*$/)) {
        detectedType = 'base64';
        details = {
            decodedLength: Buffer.from(secret, 'base64').length
        };
    } else if (secret.includes('.') && secret.split('.').length === 3) {
        detectedType = 'token';
        details = {
            format: 'jwt-like',
            parts: 3
        };
    } else if (secret.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)) {
        detectedType = 'uuid';
        details = {
            format: 'uuid-v4'
        };
    } else {
        detectedType = 'password';
        details = {
            length: secret.length,
            hasSpecialChars: /[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]/.test(secret)
        };
    }

    return {
        valid: true,
        type: detectedType,
        length: secret.length,
        details
    };
}

/**
 * Simulate using the secret as an API key
 * @param {string} secret - The API key
 * @returns {object} Simulated API response
 */
function simulateApiCall(secret) {
    // In a real scenario, this would make an actual API call
    // Here we simulate a successful authentication

    const timestamp = new Date().toISOString();
    const requestId = randomBytes(8).toString('hex');

    return {
        success: true,
        message: 'API authentication successful (simulated)',
        requestId,
        timestamp,
        apiKeyPrefix: secret.substring(0, 8) + '...',
        endpoints: {
            available: ['/api/v1/data', '/api/v1/compute', '/api/v1/status'],
            rateLimit: '1000 requests/hour'
        }
    };
}

/**
 * Encrypt a message using the secret as a key
 * @param {string} secret - The encryption key (will be hashed to 32 bytes)
 * @param {string} message - The message to encrypt
 * @returns {object} Encrypted data
 */
function encryptWithSecret(secret, message) {
    // Derive a 32-byte key from the secret
    const key = createHash('sha256').update(secret).digest();
    const iv = randomBytes(16);

    const cipher = createCipheriv('aes-256-cbc', key, iv);
    let encrypted = cipher.update(message, 'utf8', 'base64');
    encrypted += cipher.final('base64');

    return {
        algorithm: 'aes-256-cbc',
        iv: iv.toString('base64'),
        encrypted,
        message: 'Message encrypted successfully'
    };
}

/**
 * Hash the secret for verification purposes
 * @param {string} secret - The secret to hash
 * @returns {object} Hash information
 */
function hashSecret(secret) {
    const sha256 = createHash('sha256').update(secret).digest('hex');
    const sha512 = createHash('sha512').update(secret).digest('hex');

    return {
        sha256,
        sha512: sha512.substring(0, 64) + '...',
        note: 'Use these hashes to verify secret integrity without exposing the value'
    };
}

/**
 * Parse command line arguments
 * @param {string[]} args - Command line arguments
 * @returns {object} Parsed arguments
 */
function parseArgs(args) {
    const argString = args.join(' ').trim();

    if (!argString) {
        return { action: 'info' };
    }

    const parts = argString.split(',').map(p => p.trim());

    return {
        action: parts[0] || 'info',
        params: parts.slice(1)
    };
}

/**
 * Main function
 */
async function main() {
    console.log('üîì Secret Consumer iApp');
    console.log('=======================');
    console.log('Running inside iExec TEE environment');
    console.log('');

    // Check if secret is available
    console.log('üîç Checking for requester secret...');

    if (!SECRET_TO_USE) {
        console.log('‚ùå No secret found in IEXEC_APP_DEVELOPER_SECRET or IEXEC_REQUESTER_SECRET_1');
        console.log('');
        console.log('üìå To use this iApp, you need either:');
        console.log('   A. An App Secret (pushed by App Owner)');
        console.log('   B. A Requester Secret (pushed by User)');
        console.log('');

        // Write error output
        const output = {
            success: false,
            error: 'No secret provided',
            instructions: 'Ensure App Owner pushed App Secret OR provide a requester secret.'
        };

        if (!existsSync(IEXEC_OUT)) {
            mkdirSync(IEXEC_OUT, { recursive: true });
        }

        const resultPath = join(IEXEC_OUT, 'result.json');
        writeFileSync(resultPath, JSON.stringify(output, null, 2));

        const computedPath = join(IEXEC_OUT, 'computed.json');
        writeFileSync(computedPath, JSON.stringify({ 'deterministic-output-path': resultPath }));

        return;
    }

    console.log('‚úÖ Secret found!');
    console.log(`   Length: ${SECRET_TO_USE.length} characters`);
    console.log(`   Preview: ${SECRET_TO_USE.substring(0, 8)}...`);
    console.log('');

    // Parse arguments
    const args = process.argv.slice(2);
    const { action, params } = parseArgs(args);

    console.log(`üìã Action requested: ${action}`);
    console.log('');

    let result = {};

    switch (action.toLowerCase()) {
        case 'validate':
            console.log('üîç Validating secret...');
            result = {
                action: 'validate',
                validation: validateSecret(SECRET_TO_USE)
            };
            break;

        case 'use-api':
        case 'api':
            console.log('üåê Simulating API call with secret...');
            result = {
                action: 'use-api',
                validation: validateSecret(SECRET_TO_USE),
                apiResponse: simulateApiCall(SECRET_TO_USE)
            };
            break;

        case 'encrypt':
            const message = params[0] || 'Hello from iExec TEE!';
            console.log(`üîí Encrypting message: "${message}"`);
            result = {
                action: 'encrypt',
                encrypted: encryptWithSecret(SECRET_TO_USE, message)
            };
            break;

        case 'hash':
            console.log('üî¢ Hashing secret...');
            result = {
                action: 'hash',
                preview: SECRET_TO_USE.substring(0, 8) + '...',
                hashes: hashSecret(SECRET_TO_USE)
            };
            break;

        case 'info':
        default:
            console.log('‚ÑπÔ∏è  Getting secret information...');
            result = {
                action: 'info',
                secretInfo: {
                    available: true,
                    length: SECRET_TO_USE.length,
                    preview: SECRET_TO_USE.substring(0, 8) + '...',
                    validation: validateSecret(SECRET_TO_USE)
                },
                availableActions: ['validate', 'use-api', 'encrypt', 'hash', 'info']
            };
            break;
    }

    // Add metadata
    const output = {
        success: true,
        timestamp: new Date().toISOString(),
        ...result
    };

    console.log('');
    console.log('‚úÖ Action completed successfully!');

    // Ensure output directory exists
    if (!existsSync(IEXEC_OUT)) {
        mkdirSync(IEXEC_OUT, { recursive: true });
    }

    // Write the result
    const resultPath = join(IEXEC_OUT, 'result.json');
    writeFileSync(resultPath, JSON.stringify(output, null, 2));

    // Write computed.json for iExec
    const computedPath = join(IEXEC_OUT, 'computed.json');
    const computedData = {
        'deterministic-output-path': resultPath
    };
    writeFileSync(computedPath, JSON.stringify(computedData));

    console.log('üìÅ Output written to:', resultPath);
    console.log('');
    console.log('üéâ Secret consumption complete!');
}

// Run the main function
main().catch(error => {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
});
