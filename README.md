# Secret Generator & Consumer (App Secret Flow)

This project demonstrates how an application (**TargetApp**) can generate a secret within a secure enclave (TEE) and automatically push it as an **App Secret** for another application (**ConsumeApp**).

## üèóure Architecture

1.  **TargetApp (Generator)**:
    *   Runs inside a TEE enclave.
    *   Generates a secret (e.g., API Key, Private Key...).
    *   Uses the iExec SDK (`iexec.app.pushAppSecret`) to push this secret to the SMS (Secret Management Service).
    *   **Target**: The address of `ConsumeApp`.
    *   *Condition*: The wallet executing TargetApp (or its internal secret) must be the **owner** of ConsumeApp.

2.  **ConsumeApp (Consumer)**:
    *   Runs inside a TEE enclave.
    *   Automatically retrieves the secret via the environment variable `IEXEC_APP_DEVELOPER_SECRET`.
    *   This secret is available to **all** users of ConsumeApp (global secret).

## üöÄ Deployment and Testing

### 1. Prerequisites
*   Node.js v20+
*   Docker & DockerHub account
*   iApp Generator CLI (`npm install -g @iexec/iapp`)
*   RLC Tokens on Arbitrum Sepolia

### 2. Deployment Step-by-Step

**Step A: Deploy ConsumeApp** (Must be done first)

```bash
cd ConsumeApp
iapp deploy --chain arbitrum-sepolia-testnet
```
*   Save the displayed **iApp address** (e.g., `0xConsume...`).

**Step B: Deploy TargetApp**

```bash
cd ../TargetApp
iapp deploy --chain arbitrum-sepolia-testnet
```
*   When asked *"Do you want to attach an app secret?"*, answer **"no"**.
*   Save the displayed **iApp address** (e.g., `0xTarget...`).

**Important**: The wallet acting as "Owner" (deployer) must have permissions over ConsumeApp. Since you deploy both with the same wallet, this is handled automatically by the test script setup.

### 3. Running the Full Flow Test

Update your test configuration if needed, then run:

```bash
node scripts/test-full-flow.js
```

This script performs the following steps:
1.  **Setup Permission**: Configures TargetApp with the owner's private key (via an App Secret on TargetApp itself), so it has the right to `push` to ConsumeApp.
2.  **TargetApp Run**: Runs TargetApp passing it the address of ConsumeApp.
    *   *Action*: Generates "api-key" and sends it to the SMS for ConsumeApp.
3.  **ConsumeApp Run**: Runs ConsumeApp.
    *   *Action*: Reads `IEXEC_APP_DEVELOPER_SECRET` and outputs its hash.
4.  **Verification**: Compares the hash generated by TargetApp and the one read by ConsumeApp.

## üíª Code Details

### How does TargetApp push the secret?

In `TargetApp/src/app.js`:
```javascript
// Use iexec.app (not iexec.secrets) to push an App Secret
const isPushed = await iexec.app.pushAppSecret(targetAppAddress, secretValue);
```

### How does ConsumeApp read the secret?

In `ConsumeApp/src/app.js`:
```javascript
// The worker automatically injects the application secret here
const APP_SECRET = process.env.IEXEC_APP_DEVELOPER_SECRET;

if (APP_SECRET) {
    console.log("Secret found!");
} else {
    console.log("No App Secret defined by the owner.");
}
```

## üîß Current Addresses 

*   **TargetApp**: `0x`
*   **ConsumeApp**: `0x`
*   **Network**: Arbitrum Sepolia Testnet

## ‚ö†Ô∏è Security Notes

*   **App Secret = Global**: An "App Secret" is unique to the application. If TargetApp updates it, it changes for **all** users of ConsumeApp instantly.
*   **Permissions**: Only the application owner (on the blockchain) can define its App Secret. This is why TargetApp needs the owner's key (securely injected) to perform this action.
